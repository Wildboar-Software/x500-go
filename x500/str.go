// X.500 Directory Data Structures with ASN.1 Encoding and Decoding
package x500

import (
	"encoding/asn1"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"

	"github.com/Wildboar-Software/x500-go/teletex"
)

// Generated by ChatGPT 4o.
func PrintBitString(bitString asn1.BitString) string {
	if len(bitString.Bytes) == 0 {
		return "''B" // Empty BitString
	}

	// Convert bytes to a binary string representation
	var binaryStr strings.Builder
	bitCount := 0

	for _, b := range bitString.Bytes {
		for j := 7; j >= 0; j-- {
			if bitCount >= bitString.BitLength {
				break // Stop once we reach the valid bit count
			}
			if b&(1<<j) != 0 {
				binaryStr.WriteByte('1')
			} else {
				binaryStr.WriteByte('0')
			}
			bitCount++
		}
	}

	// LDAP format: '101010'B
	return fmt.Sprintf("'%s'B", binaryStr.String())
}

func ASN1RawValueToStr(value asn1.RawValue) (output string, err error) {
	if value.Class != asn1.ClassUniversal {
		// TODO: Something better than this.
		return fmt.Sprintf("% x", value.FullBytes), nil
	}
	switch value.Tag {
	case asn1.TagBoolean:
		{
			if len(value.Bytes) == 0 {
				return "ERROR", errors.New("BOOLEAN encoded on zero bytes")
			}
			if value.Bytes[0] > 0 {
				return "TRUE", nil
			} else {
				return "FALSE", nil
			}
		}
	case asn1.TagInteger:
		fallthrough
	case asn1.TagEnum:
		{
			var decoded int = 0
			rest, err := asn1.Unmarshal(value.FullBytes, &decoded)
			if err != nil {
				return "?", err
			}
			if len(rest) > 0 {
				return "?", err
			}
			return fmt.Sprint(decoded), nil
		}
	case asn1.TagOctetString:
		{
			return fmt.Sprintf("% x", value.Bytes), nil
		}
	case asn1.TagNull:
		{
			return "NULL", nil
		}
	case asn1.TagOID:
		{
			oid := asn1.ObjectIdentifier{}
			rest, err := asn1.Unmarshal(value.FullBytes, &oid)
			if err != nil {
				return "?", err
			}
			if len(rest) > 0 {
				return "?", err
			}
			return oid.String(), nil
		}
	case asn1.TagUTF8String:
		fallthrough
	case asn1.TagNumericString:
		fallthrough
	case asn1.TagPrintableString:
		fallthrough
	case asn1.TagT61String:
		fallthrough
	case asn1.TagIA5String:
		fallthrough
	case asn1.TagGeneralString:
		fallthrough
	case asn1.TagGeneralizedTime:
		fallthrough
	case asn1.TagUTCTime:
		{
			return string(value.Bytes[:]), nil
		}
	default:
		{
			return fmt.Sprintf("% x", value.FullBytes), nil
		}
	}
}

// Generated by ChatGPT 4o.
func encodeUniversalString(input string) []byte {
	runes := []rune(input)               // Convert string to runes (Unicode code points)
	output := make([]byte, 4*len(runes)) // Allocate 4 bytes per rune

	for i, r := range runes {
		// Encode each Unicode code point as a 4-byte big-endian value
		binary.BigEndian.PutUint32(output[i*4:], uint32(r))
	}

	return output
}

// Generated by ChatGPT 4o.
func encodeBMPString(input string) []byte {
	runes := []rune(input)               // Convert string to runes (Unicode code points)
	output := make([]byte, 2*len(runes)) // Allocate 2 bytes per rune

	for i, r := range runes {
		if r > 0xFFFF {
			// BMPString only supports UCS-2, so characters beyond U+FFFF are invalid
			panic(fmt.Sprintf("Character U+%X is outside BMP range", r))
		}
		// Encode each Unicode code point as a 2-byte big-endian value
		binary.BigEndian.PutUint16(output[i*2:], uint16(r))
	}

	return output
}

func NewDirectoryString(s string) asn1.RawValue {
	return asn1.RawValue{
		Class:      asn1.ClassUniversal,
		Tag:        asn1.TagUTF8String,
		IsCompound: false,
		Bytes:      []byte(s),
	}
}

func universalStringFromBytes(bytes []byte) (s string, err error) {
	if len(bytes)%4 != 0 {
		return "", errors.New("invalid universalstring length")
	}
	if len(bytes) == 0 {
		return "", nil
	}
	runes := make([]rune, 0, len(bytes)/4)

	l := len(bytes)
	hasNullTerminator := bytes[l-1] == 0 && bytes[l-2] == 0 && bytes[l-3] == 0 && bytes[l-4] == 0
	if hasNullTerminator {
		bytes = bytes[:l-4] // strip it
	}

	for len(bytes) > 0 {
		nextRune := rune(bytes[0])<<24 + rune(bytes[1])<<16 + rune(bytes[2])<<8 + rune(bytes[3])
		runes = append(runes, nextRune)
		bytes = bytes[4:]
	}

	return string(runes), nil
}

func DirectoryStringToString(ds asn1.RawValue) (s string, err error) {
	if ds.Class != asn1.ClassUniversal {
		return "", errors.New("non-universal tag directory string")
	}
	if ds.Tag == 28 {
		return universalStringFromBytes(ds.Bytes)
	}
	if len(ds.FullBytes) > 0 {
		rest, err := asn1.Unmarshal(ds.FullBytes, &s)
		if err != nil {
			return "", err
		}
		if len(rest) > 0 {
			return s, errors.New("trailing bytes after directorystring")
		}
	}
	if len(ds.Bytes) == 0 {
		return "", nil
	}
	// It is an edge case and a bug for an asn1.RawValue to have .Bytes
	// populated, but not .FullBytes, but we still attempt to handle it.
	switch ds.Tag {
	case asn1.TagUTF8String:
		fallthrough
	case asn1.TagPrintableString:
		return string(ds.Bytes), nil
	case asn1.TagT61String:
		return teletex.TeletexToUTF8(ds.Bytes), nil
	case asn1.TagBMPString:
		// Why, yes, I would LOVE to marshal a value just to immediately
		// unmarshal it to a string, because I do not want to re-implement the
		// same exact BMPString decoding the Go standard library already has
		// for this silly little edge case where FullBytes is not populated and
		// the string happens to be a BMPString. Blame Golang's ASN.1 library.
		encodedbmp, err := asn1.Marshal(ds)
		if err != nil {
			return "", err
		}
		rest, err := asn1.Unmarshal(encodedbmp, &s)
		if err != nil {
			return "", err
		}
		if len(rest) > 0 {
			return s, errors.New("trailing bytes after bmpstring")
		}
		return s, nil
	default:
		return "", fmt.Errorf("invalid tag for directorystring: %d", ds.Tag)
	}
}
